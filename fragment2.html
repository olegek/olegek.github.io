<!DOCTYPE html>
<html>
<body>
<h1 id="header", align="center">MOVA.io</h1>
<h1 id="ios-projects-general-rules", align="center">iOS projects general rules</h1>
<p align="center">Comments and suggestions are <strong>STRONGLY ENCOURAGED</strong>, so feel free to open an issue.</p>
<h1 id="contents">Contents</h1>
<ul>
<li><a href="#project-general-rules">Project general rules</a><ul>
<li><a href="#project-tree-structure">Project Tree Structure</a></li>
<li><a href="#file-blocks-sctructure">File blocks sctructure</a></li>
<li><a href="#security-guide">Security Guide</a></li>
<li><a href="#branch-guide">Branch Guide</a></li>
</ul>
</li>
<li><a href="#design-architecture">Design Architecture</a><ul>
<li><a href="#design-pattern">Design Pattern</a></li>
<li><a href="#managers--services">Managers &amp; Services</a></li>
<li><a href="#helpers">Helpers</a></li>
</ul>
</li>
<li><a href="#code-style-rules">Code style rules</a><ul>
<li><a href="#conventions">Conventions</a></li>
<li><a href="#naming">Naming</a></li>
<li><a href="#code-organization">Code Organization</a></li>
<li><a href="#assets">Assets</a><ul>
<li><a href="#images">Images</a></li>
<li><a href="#fonts">Fonts</a></li>
<li><a href="#colors">Colors</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="project-general-rules">Project general rules</h1>
<h2 id="project-tree-structure">Project Tree Structure</h2>
<p align="center"><img width="338" alt="Project Tree Structure" src="https://user-images.githubusercontent.com/25178444/69141915-6018cc00-0ace-11ea-912d-06fe31cc86b4.png"></p>
<h2 id="file-blocks-structure">File blocks structure</h2>
<h3 id="code-structure-for-files">Code structure for files</h3>
<p><em>(All sections are optional and used if needed)</em></p>
<pre><code class="lang-swift">
<span class="hljs-comment">// MARK: - Private properties (views, DateFormatter etc.)</span>

<span class="hljs-comment">// MARK: - Properties</span>

<span class="hljs-comment">// MARK: - Closure/Delegate</span>

<span class="hljs-comment">// MARK: - Lifecycle</span>

<span class="hljs-comment">// MARK: - Setup with model</span>

<span class="hljs-comment">// MARK: - Actions</span>

<span class="hljs-comment">// MARK: - Override</span>

<span class="hljs-comment">// MARK: - Help methods</span>
</code></pre>
<h2 id="security-guide">Security Guide</h2>
<p>1) Use password on your Mac
2) When you leave your workspace lock Mac (use hot key Command+Control+Q). For detail information  <a href="https://macpaw.com/how-to/lock-mac-screen">goto</a>
3) Use FileVault on Mac.  <a href="https://support.apple.com/en-us/HT204837">Setup Guide</a>
4) Сhange your password from time to time, don&#39;t pass password.
5) If it possible setup SSL
6) Use 2-Factor Authentication for Accounts Used for Work:</p>
<ul>
<li>Atlassian (Jira, Confluence)</li>
<li>Bitbucket</li>
<li>Gmail/Google</li>
<li>Github</li>
<li>Slack (including workspace used for client work)</li>
<li>Trello
7) Do not add certificates or profiles to the repository, do not store passwords in the repository/code
8) Don&#39;t use the main branch for work</li>
</ul>
<h2 id="branch-guide">Branch Guide</h2>
<p>1) Don&#39;t use the main branch for work! Create:</p>
<ul>
<li>branch &quot;development&quot; for development</li>
<li>branch &quot;release&quot; for the release version</li>
<li>branch &quot;beta-testing&quot; for versions delivered to the client for a test (e.g. TestFlight)</li>
</ul>
<p>2) Commit names:</p>
<ul>
<li><code>development</code> branch:<ul>
<li>use Jira task name (or task name/number from trello etc) and short description of the work done in this commit. For example: <code>PB-248, added profile screen</code></li>
</ul>
</li>
<li><code>release</code> and <code>beta-testing</code> branches:<ul>
<li>when sending a build to the Store, or to the Testflight, you can use the number of the release/beta verion, e.g: &quot;1.0.2 #19&quot;</li>
</ul>
</li>
</ul>
<p>3) Create commit for every new task
4) If you work in a team, use one branch for every separate task. When done, merge task branch into the &quot;develepment&quot; branch
5) Always work on latest code: before starting new feature, make sure to sync with main active branch</p>
<h1 id="design-architecture">Design Architecture</h1>
<h2 id="design-pattern">Design Pattern</h2>
<p>The design pattern we will begin adopting should make the app more modularized and allow for easy navigation through the codebase. It is inspired by MVVM+Coordinator, an alternative to standard MVC, where the business logic is separated from the UI in a <code>ViewModel</code>.</p>
<p>Each component in <code>Application</code> (see <a href="#project-tree-structure">Project Tree Structure</a>) should include <code>$VCName$ViewController.swift</code>, <code>$VMName$ViewModel.swift</code>, (several) <code>$VName$View.swift</code> and (several) <code>$MName$Model.swift</code>.</p>
<p><strong><code>Model.swift</code></strong></p>
<ul>
<li>Represents a specific model e.g. <code>UserModel</code>, <code>PropertyModel</code>, <code>History</code> etc.</li>
<li>Does not contain any logic.</li>
</ul>
<p><strong><code>ViewController.swift</code></strong></p>
<ul>
<li>Does not contain any business logic (networking, database, configuring cells, converting variables etc.)</li>
<li>Can&#39;t interact with the <code>Model</code>s directly, only with the <code>ViewModel</code>s and <code>View</code>s.</li>
</ul>
<p><strong><code>View.swift</code></strong></p>
<ul>
<li>Represents a UI element e.g. <code>GuestDetailsView</code>, <code>StretchyHeaderView</code> etc.</li>
<li>Does not contain any logic.</li>
<li>Should not be tight to the view controller in order to be extracted as a framework (if applicable).</li>
</ul>
<p><strong><code>ViewModel.swift</code></strong></p>
<ul>
<li>Contains all the business logic.</li>
<li>Communicates with the <code>Coordinators</code>s, <code>Model</code>s and <code>ViewController</code>s(with callbacks, ViewModel should not know about ViewController) but can&#39;t interact with the UI (<code>View</code>s).</li>
</ul>
<p><strong><code>Coordinator.swift</code></strong></p>
<ul>
<li>Contains all transition logic</li>
<li>Crates new controllers and their view models</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/25178444/69136881-5db17480-0ac4-11ea-9a74-329e8a56f5b5.png" alt="MVVM+Coordinator+MoyaNetworking Architecture"></p>
<p>Moya <a href="https://github.com/Moya/Moya">Documentation</a> , <a href="https://www.raywenderlich.com/5121-moya-tutorial-for-ios-getting-started">Tutorial</a></p>
<p>Snapkit <a href="http://snapkit.io">Documentation</a> , <a href="https://www.raywenderlich.com/3225401-snapkit-for-ios-constraints-in-a-snap">Tutorial</a></p>
<p>Use the principle of Single Responsible, one class - should perform one action.</p>
<p>For TableView sections Header/Foother use <code>UITableViewHeaderFooterView</code></p>
<p>Similar situation is when the controller has a UIView with some UI components it should be transferred to a separate class that is inherited from the UIView and communicates with the VC</p>
<h2 id="managers-services">Managers &amp; Services</h2>
<p>There should be clear distinguishing between <code>Managers</code> and <code>Services</code>. In simple terms:</p>
<p><strong>Manager</strong> - a singleton object which includes functionality required during the lifetime of the application. We should keep the number of managers to a minimum and ONLY create one when needed.</p>
<p><strong>Services</strong> - a service is NOT a singleton and serves a very specific purpose. It should be independent of any custom logic and be fully reusable. Most services will eventually be transformed into frameworks (swift packages). E.g. <code>PDFSplitService</code>.</p>
<h2 id="helpers">Helpers</h2>
<p><code>Helpers</code> are NOT <code>Services</code>, <code>Managers</code> or <code>Data Models</code>. <code>Helpers</code> are classes, structs, extensions with the purpose of extracting some basic logic. Typically, one helper is used across multiple classes.</p>
<p><strong>Helpers CAN include:</strong></p>
<ul>
<li>Extensions (e.g. <code>String+Split.swift</code>).</li>
<li>Methods for converting data.</li>
<li>Handle configurations (e.g. <code>Device.swift</code>)</li>
</ul>
<p><strong>Helpers CAN NOT include:</strong></p>
<ul>
<li>Complex networking calls.</li>
<li>Database interactions.</li>
<li>Data models.</li>
</ul>
<h1 id="code-style-rules">Code style rules</h1>
<h2 id="conventions">Conventions</h2>
<h3 id="viewer">Viewer</h3>
<p>For best practice use select some code and use Editor -&gt; Format -&gt; Re - Indent</p>
<h3 id="names-of-types-and-variables">Names of types and variables</h3>
<p>Follow case conventions. Names of <strong>types and protocols</strong> are UpperCamelCase. Everything else is lowerCamelCase. Acronyms and initialisms that commonly appear as all upper case in US English should be uniformly up- or down-cased
according to case conventions. Other acronyms should be treated as ordinary words.</p>
<h5 id="preferred-">Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-selector-tag">var</span> linesArray: [Line]
<span class="hljs-selector-tag">var</span> shape: Shape

<span class="hljs-selector-tag">var</span> utf8Bytes: [UTF8.CodeUnit]
<span class="hljs-selector-tag">var</span> isRepresentableAsASCII = true
<span class="hljs-selector-tag">var</span> userSMTPServer: SecureSMTPServer
</code></pre>
<h5 id="not-preferred-">Not Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-selector-tag">var</span> LinesArray: [Line]
<span class="hljs-selector-tag">var</span> lines_array: [Line]
<span class="hljs-selector-tag">var</span> sHaPe: Shape

<span class="hljs-selector-tag">var</span> UTF8Bytes: [UTF8.CodeUnit]
</code></pre>
<h3 id="sort-values-by-equal-type">Sort Values by equal type</h3>
<h5 id="preferred-">Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-selector-tag">var</span> tableView = UITableView()

<span class="hljs-selector-tag">var</span> headerView = UIView()
<span class="hljs-selector-tag">var</span> buttonsView = UIView()
<span class="hljs-selector-tag">var</span> footherView = UIView()

<span class="hljs-selector-tag">var</span> news: [News]
<span class="hljs-selector-tag">var</span> sortedNews: [News]
</code></pre>
<h5 id="not-preferred-">Not Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-selector-tag">var</span> headerView = UIView()
<span class="hljs-selector-tag">var</span> tableView = UITableView()
<span class="hljs-selector-tag">var</span> buttonsView = UIView()
<span class="hljs-selector-tag">var</span> news: [News]
<span class="hljs-selector-tag">var</span> sortedNews: [News]
<span class="hljs-selector-tag">var</span> footherView = UIView()
</code></pre>
<h3 id="extensions">Extensions</h3>
<p>Use extension to expand classes functionality against global functions.</p>
<h5 id="preferred-">Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">CGRect</span> </span>{

  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doesIntersect</span><span class="hljs-params">(<span class="hljs-number">_</span> anotherRect: CGRect)</span></span> -&gt; <span class="hljs-type">Bool</span> { ... }

}
</code></pre>
<h5 id="not-preferred-">Not Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-comment">// Global Scope</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doRectanglesIntersect</span><span class="hljs-params">(<span class="hljs-number">_</span> rect1: CGRect, <span class="hljs-number">_</span> rect2: CGRect)</span></span> -&gt; <span class="hljs-type">Bool</span> { ... }
</code></pre>
<h3 id="methods-names">Methods names</h3>
<p>Methods can share a base name when they share the same basic meaning or when they operate in distinct domains.
Examples:</p>
<ol>
<li><p>The following is encouraged, since the methods do
essentially the same things.</p>
</li>
<li><p>And since geometric types and collections are separate
domains, this is also fine in the same program.</p>
</li>
<li><p>These index methods have different semantics, and should
have been named differently.</p>
</li>
<li><p>Avoid “overloading on return type” because it causes
ambiguities in the presence of type inference.</p>
</li>
</ol>
<h5 id="preferred-">Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-comment">// 1</span>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Shape</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">contains</span><span class="hljs-params">(<span class="hljs-number">_</span> other: Point)</span></span> -&gt; <span class="hljs-type">Bool</span> { ... }

  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">contains</span><span class="hljs-params">(<span class="hljs-number">_</span> other: Shape)</span></span> -&gt; <span class="hljs-type">Bool</span> { ... }

  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">contains</span><span class="hljs-params">(<span class="hljs-number">_</span> other: LineSegment)</span></span> -&gt; <span class="hljs-type">Bool</span> { ... }
}

<span class="hljs-comment">// 2</span>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Collection</span> <span class="hljs-title">where</span> <span class="hljs-title">Element</span> : <span class="hljs-title">Equatable</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">contains</span><span class="hljs-params">(<span class="hljs-number">_</span> sought: Element)</span></span> -&gt; <span class="hljs-type">Bool</span> { ... }
}
</code></pre>
<h5 id="not-preferred-">Not Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-comment">// 3</span>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Database</span> </span>{
  <span class="hljs-comment">// Rebuilds the database's search index</span>
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">index</span><span class="hljs-params">()</span></span> { ... }

  <span class="hljs-comment">// Returns the n`th row in the given table.</span>
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">index</span><span class="hljs-params">(<span class="hljs-number">_</span> n: Int, inTable: TableID)</span></span> -&gt; <span class="hljs-type">TableRow</span> { ... }
}

<span class="hljs-comment">// 4</span>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Box</span> </span>{
  <span class="hljs-comment">// Returns the `Int` stored in `self`, if any, and `nil` otherwise.</span>
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">value</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Int</span>? { ... }

  <span class="hljs-comment">// Returns the `String` stored in `self`, if any, and `nil` otherwise.</span>
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">value</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">String</span>? { ... }
}
</code></pre>
<h3 id="use-short-context">Use short context</h3>
<p>Use compiler inferred context to write shorter, clear code.</p>
<h5 id="preferred-">Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-keyword">let</span> <span class="hljs-attr">selector</span> = <span class="hljs-comment">#selector(viewDidLoad)</span>

view.<span class="hljs-attr">backgroundColor</span> = .red

<span class="hljs-keyword">let</span> <span class="hljs-attr">toView</span> = context.view(forKey: .to)

<span class="hljs-keyword">let</span> <span class="hljs-attr">view</span> = UIView(frame: .zero)
</code></pre>
<h5 id="not-preferred-">Not Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-keyword">let</span> <span class="hljs-attr">selector</span> = <span class="hljs-comment">#selector(ViewController.viewDidLoad)</span>

view.<span class="hljs-attr">backgroundColor</span> = UIColor.red

<span class="hljs-keyword">let</span> <span class="hljs-attr">toView</span> = context.view(forKey: UITransitionContextViewKey.to)

<span class="hljs-keyword">let</span> <span class="hljs-attr">view</span> = UIView(frame: CGRect.zero)
</code></pre>
<h2 id="naming">Naming</h2>
<h3 id="funcions-parameters-names">Funcions parameters names</h3>
<p>Choose parameter names to serve documentation. Even though parameter names do not appear at a function’s point of use, they play an important explanatory role.</p>
<p>Choose names to make it easy to read.</p>
<h5 id="preferred-">Preferred:</h5>
<p>These names make documentation read naturally.</p>
<pre><code class="lang-swift"><span class="hljs-comment">// Return an `Array` containing the elements of `self` that satisfy `predicate`.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">filter</span><span class="hljs-params">(<span class="hljs-number">_</span> predicate: <span class="hljs-params">(Element)</span></span></span> -&gt; <span class="hljs-type">Bool</span>) -&gt; [<span class="hljs-type">Generator</span>.<span class="hljs-type">Element</span>]

<span class="hljs-comment">// Replace the given `subRange` of elements with `newElements`.</span>
<span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">replaceRange</span><span class="hljs-params">(<span class="hljs-number">_</span> subRange: Range, with newElements: [E])</span></span>
</code></pre>
<h5 id="not-preferred-">Not Preferred:</h5>
<p>These make the code awkward and ungrammatical.</p>
<pre><code class="lang-swift"><span class="hljs-comment">// Return an Array containing the elements of self that satisfy includedInResult.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">filter</span><span class="hljs-params">(<span class="hljs-number">_</span> includedInResult: <span class="hljs-params">(Element)</span></span></span> -&gt; <span class="hljs-type">Bool</span>) -&gt; [<span class="hljs-type">Generator</span>.<span class="hljs-type">Element</span>]

<span class="hljs-comment">// Replace the range of elements indicated by r with the contents of with.</span>
<span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">replaceRange</span><span class="hljs-params">(<span class="hljs-number">_</span> r: Range, with: [E])</span></span>
</code></pre>
<h3 id="delegate-methods-naming">Delegate methods naming</h3>
<p>When creating custom delegate methods, an unnamed first parameter should be the delegate source.</p>
<h5 id="preferred-">Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">namePickerView</span><span class="hljs-params">(<span class="hljs-number">_</span> namePickerView: NamePickerView, didSelectName name: String)</span></span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">namePickerViewShouldReload</span><span class="hljs-params">(<span class="hljs-number">_</span> namePickerView: NamePickerView)</span></span> -&gt; <span class="hljs-type">Bool</span>
</code></pre>
<h5 id="not-preferred-">Not Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">didSelectName</span><span class="hljs-params">(namePicker: NamePickerViewController, name: String)</span></span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">namePickerShouldReload</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Bool</span>
</code></pre>
<h3 id="avoid-ambiguity-naming">Avoid ambiguity naming</h3>
<p>Include all the words needed to avoid ambiguity for a person reading code where the name is used.</p>
<p> Example:
 If we were to omit the word <strong>at</strong> from the function signature, it could imply to the reader that the function searches for and
 removes an element equal to x, rather than using x to indicate the
 position of the element to remove.</p>
<h5 id="preferred-">Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">List</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">remove</span><span class="hljs-params">(at position: Index)</span></span> -&gt; <span class="hljs-type">Element</span>
}

employees.remove(at: x)
</code></pre>
<h5 id="not-preferred-">Not Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-comment">// unclear: are we removing x?</span>
employees.<span class="hljs-built_in">remove</span>(x)
</code></pre>
<h3 id="omit-needless-words">Omit needless words</h3>
<p>Every word in a name should convey useful information at the use site. More words may be needed to clarify intent or disambiguate meaning, but those that are redundant with information the reader already possesses should be omitted. In particular, omit words that merely repeat type information.
Example:
In this case, the word Element adds nothing useful at the call site.</p>
<h5 id="preferred-">Preferred:</h5>
<pre><code class="lang-swift">func <span class="hljs-built_in">remove</span>(<span class="hljs-symbol">_</span> <span class="hljs-built_in">member</span>: Element) -&gt; Element?

allViews.<span class="hljs-built_in">remove</span>(cancelButton)
</code></pre>
<h5 id="not-preferred-">Not Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(<span class="hljs-number">_</span> member: Element)</span></span> -&gt; <span class="hljs-type">Element</span>?

allViews.removeElement(cancelButton)
</code></pre>
<h3 id="name-should-match-the-role">Name should match the role</h3>
<p>Name variables, parameters, and associated types according to their roles.</p>
<h5 id="preferred-">Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-keyword">var</span> greeting = <span class="hljs-string">""</span><span class="hljs-type">Hello</span><span class="hljs-string">""</span>

<span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ViewController</span> </span>{
  associatedtype <span class="hljs-type">ContentView</span> : <span class="hljs-type">View</span>
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductionLine</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">restock</span><span class="hljs-params">(from supplier: Factory)</span></span>
}

<span class="hljs-comment">//</span>

<span class="hljs-keyword">let</span> greetingString = <span class="hljs-string">""</span>http:<span class="hljs-comment">//...""</span>
<span class="hljs-keyword">let</span> greetingURL = <span class="hljs-type">URL</span>(string: greetingString)
</code></pre>
<h5 id="not-preferred-">Not Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-keyword">var</span> string = <span class="hljs-string">""</span><span class="hljs-type">Hello</span><span class="hljs-string">""</span>

<span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ViewController</span> </span>{
  associatedtype <span class="hljs-type">ViewType</span> : <span class="hljs-type">View</span>
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductionLine</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">restock</span><span class="hljs-params">(from factory: Factory)</span></span>
}

<span class="hljs-comment">//</span>

<span class="hljs-keyword">let</span> greeting1 = <span class="hljs-string">""</span>http:<span class="hljs-comment">//...""</span>
<span class="hljs-keyword">let</span> greeting2 = <span class="hljs-type">URL</span>(string: greeting1)
</code></pre>
<h3 id="selectors-naming">Selectors naming</h3>
<p>Functions that are being used as button selectors directly should be named using the suffix -ButtonAction.</p>
<h5 id="preferred-">Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-symbol">@objc</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">saveButtonAction</span><span class="hljs-params">()</span> {</span>

}
</code></pre>
<h5 id="not-preferred-">Not Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-symbol">@objc</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> {</span>

}
</code></pre>
<h3 id="bool-functions-naming">Bool functions naming</h3>
<p>Uses of Bool functions and properties should be read as assertions about the receiver when the use is non-mutating. A verb at the beginning of the name is strongly recommended.</p>
<h5 id="preferred-">Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-selector-tag">x</span><span class="hljs-selector-class">.isEmpty</span>
<span class="hljs-selector-tag">line1</span><span class="hljs-selector-class">.doesIntersect</span>(<span class="hljs-selector-tag">line2</span>)
</code></pre>
<h5 id="not-preferred-">Not Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-selector-tag">x</span><span class="hljs-selector-class">.empty</span>
<span class="hljs-selector-tag">line1</span><span class="hljs-selector-class">.intersects</span>(<span class="hljs-selector-tag">line2</span>)
</code></pre>
<h2 id="code-organization">Code Organization</h2>
<h3 id="parentheses-around-conditionals">Parentheses around conditionals</h3>
<p>Parentheses around conditionals are not required and should be omitted.</p>
<h5 id="preferred-">Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-keyword">if</span> <span class="hljs-built_in">name</span> == <span class="hljs-string">""</span>Hello<span class="hljs-string">""</span> {
  print(<span class="hljs-string">""</span>World<span class="hljs-string">""</span>)
}
</code></pre>
<h5 id="not-preferred-">Not Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">name</span> == <span class="hljs-string">""</span>Hello<span class="hljs-string">""</span>) {
  print(<span class="hljs-string">""</span>World<span class="hljs-string">""</span>)
}
</code></pre>
<h3 id="avoid-self">Avoid self</h3>
<p>Avoid self. when it&#39;s possible. This will make your code cleaner.</p>
<h5 id="preferred-">Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-selector-tag">tableView</span><span class="hljs-selector-class">.reloadData</span>()
</code></pre>
<h5 id="not-preferred-">Not Preferred:</h5>
<pre><code class="lang-swift">self<span class="hljs-selector-class">.tableView</span><span class="hljs-selector-class">.reloadData</span>()
</code></pre>
<h3 id="avoid-useless-methods-for-computed-properties">Avoid useless methods for computed properties</h3>
<p>For conciseness, if a computed property is read-only, omit the get clause. The get clause is required only when a set clause is provided.</p>
<h5 id="preferred-">Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-keyword">var</span> diameter: <span class="hljs-built_in">Double</span> {
  <span class="hljs-keyword">return</span> radius * <span class="hljs-number">2</span>
}
</code></pre>
<h5 id="not-preferred-">Not Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-keyword">var</span> diameter: <span class="hljs-built_in">Double</span> {
  <span class="hljs-keyword">get</span> {
     <span class="hljs-keyword">return</span> radius * <span class="hljs-number">2</span>
  }
}
</code></pre>
<h3 id="omit-needless-arguments-for-target-functions-">Omit needless arguments for target functions.</h3>
<h5 id="preferred-">Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-symbol">@objc</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">saveButtonActtion</span><span class="hljs-params">()</span> {</span>
  // sender is <span class="hljs-literal">not</span> needed
}
</code></pre>
<h5 id="not-preferred-">Not Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-meta">@objc</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">saveButtonActtion</span><span class="hljs-params">(<span class="hljs-number">_</span> sender: UIButton)</span></span> {
  <span class="hljs-comment">// sender is not needed</span>
}
</code></pre>
<h3 id="ternary-operator">Ternary operator</h3>
<p>Prefer to use ternary operator ? : during assignment of a variable with a simple condition.</p>
<h5 id="preferred-">Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-keyword">label</span>.<span class="bash">textColor = isAllowed ? .gray : .red</span>
</code></pre>
<h5 id="not-preferred-">Not Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-keyword">if</span> isAllowed {
  <span class="hljs-selector-tag">label</span><span class="hljs-selector-class">.textColor</span> = <span class="hljs-selector-class">.gray</span>
} <span class="hljs-keyword">else</span> {
  <span class="hljs-selector-tag">label</span><span class="hljs-selector-class">.textColor</span> = <span class="hljs-selector-class">.red</span>
}
</code></pre>
<h3 id="method-braces">Method braces</h3>
<p>Method braces and other braces (if / switch / while etc.) always open on the same line as the statement but close on a new line.</p>
<h5 id="preferred-">Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-keyword">if</span> user<span class="hljs-selector-class">.isHappy</span> {
  <span class="hljs-comment">// Do something</span>
} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">// Do something else</span>
}
</code></pre>
<h5 id="not-preferred-">Not Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-keyword">if</span> user<span class="hljs-selector-class">.isHappy</span>
{
  <span class="hljs-comment">// Do something</span>
} <span class="hljs-keyword">else</span>
{
  <span class="hljs-comment">// Do something else</span>
}
</code></pre>
<h3 id="separate-methods-logic">Separate methods logic</h3>
<p>Whitespaces and comments within methods should separate logic blocks of functionality. But if your function has to many blocks maybe it&#39;s a chance to split the logic to make it less complex.</p>
<h5 id="preferred-">Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-selector-tag">func</span> <span class="hljs-selector-tag">hugeFunction</span>() {

  <span class="hljs-comment">//</span>
  <span class="hljs-comment">// parsing the input data</span>

  <span class="hljs-selector-attr">[blockOfFunctionality1]</span>

  <span class="hljs-comment">//</span>
  <span class="hljs-comment">// filtering data</span>

  <span class="hljs-selector-attr">[blockOfFunctionality2]</span>

  <span class="hljs-comment">//</span>
  <span class="hljs-comment">// sorting results</span>

  <span class="hljs-selector-attr">[blockOfFunctionality3]</span>
}
</code></pre>
<h5 id="not-preferred-">Not Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-selector-tag">func</span> <span class="hljs-selector-tag">hugeFunction</span>() {
  <span class="hljs-selector-attr">[blockOfFunctionality1]</span>
  <span class="hljs-selector-attr">[blockOfFunctionality2]</span>
  <span class="hljs-selector-attr">[blockOfFunctionality3]</span>
}
</code></pre>
<h3 id="function-declarations">Function declarations</h3>
<p>Keep short function declarations on one line including the opening brace.
For functions with long signatures, use line breaks after each parameter and add an extra indent on subsequent lines.</p>
<pre><code class="lang-swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">shortFunction</span><span class="hljs-params">(<span class="hljs-number">_</span> argument: Int)</span></span> -&gt; <span class="hljs-type">Bool</span> {

}
</code></pre>
<pre><code class="lang-swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longFunction</span><span class="hljs-params">(
    argument1: Int,
    argument2: Double,
    argument3: Float)</span></span> -&gt; <span class="hljs-type">Bool</span> {

}
</code></pre>
<h3 id="closure-return-value">Closure return value</h3>
<p>Don&#39;t use (Void) to represent the lack of an input. Use () instead. Only use Void instead of () for closure and function outputs.</p>
<h5 id="preferred-">Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-keyword">let</span> closure: <span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> Void
</code></pre>
<h5 id="not-preferred-">Not Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-keyword">let</span> closure: <span class="hljs-function"><span class="hljs-params">(Void)</span> -&gt;</span> Void
<span class="hljs-keyword">let</span> closure: <span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> ()
</code></pre>
<h3 id="avoid-generic-declaration">Avoid generic declaration</h3>
<p>Prefer the shortcut versions of type declarations over the full generics syntax.</p>
<h5 id="preferred-">Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-comment">"var deviceModels: [String]</span>
var employee<span class="hljs-variable">s:</span> [In<span class="hljs-variable">t:</span> String]
var faxNumber: Int?<span class="hljs-comment">"</span>
</code></pre>
<h5 id="not-preferred-">Not Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-keyword">var</span> deviceModels: <span class="hljs-type">Array</span>&lt;<span class="hljs-keyword">String</span>&gt;
<span class="hljs-keyword">var</span> employees: <span class="hljs-type">Dictionary</span>&lt;<span class="hljs-keyword">Int</span>, <span class="hljs-keyword">String</span>&gt;
<span class="hljs-keyword">var</span> faxNumber: <span class="hljs-type">Optional</span>&lt;<span class="hljs-keyword">Int</span>&gt;
</code></pre>
<h3 id="use-weak-self-for-closures">Use weak self for closures</h3>
<p><a href="https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html">Apple documentation</a> article which describes how to use weak and unowned.</p>
<p>Extend object lifetime using [weak self] and guard let self = self else { return } idiom.</p>
<p>[weak self] is preferred over [unowned self] where it is not immediately obvious that self outlives the closure.</p>
<p>Global closures don&#39;t capture variables. In this case you don&#39;t have to use [weak self] or [unowned self], except completion handlers, since there is no guarantee that self will be still in the memory on closure call.</p>
<p>Explicitly extending lifetime is preferred to optional chaining.</p>
<h5 id="preferred-">Preferred:</h5>
<pre><code class="lang-swift">resource.request().onComplete { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] response <span class="hljs-keyword">in</span>
  <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword">self</span> = <span class="hljs-keyword">self</span> <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> }

  <span class="hljs-keyword">let</span> model = <span class="hljs-keyword">self</span>.updateModel(response)
  <span class="hljs-keyword">self</span>.updateUI(model)
}
</code></pre>
<h5 id="not-preferred-">Not Preferred:</h5>
<pre><code class="lang-swift">resource.<span class="hljs-built_in">request</span>().onComplete { <span class="hljs-built_in">response</span> <span class="hljs-keyword">in</span>
  <span class="hljs-keyword">let</span> model = self?.updateModel(<span class="hljs-built_in">response</span>)
  self?.updateUI(model)
}
</code></pre>
<h2 id="for-where-loops">For-Where Loops</h2>
<h5 id="preferred-">Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-keyword">for</span> <span class="hljs-literal">item</span> <span class="hljs-keyword">in</span> collection <span class="hljs-keyword">where</span> <span class="hljs-literal">item</span>.hasProperty {
  // ...
}
</code></pre>
<h5 id="not-preferred-">Not Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> collection {
  <span class="hljs-keyword">if</span> item<span class="hljs-selector-class">.hasProperty</span> {
    <span class="hljs-comment">// ...</span>
  }
}
</code></pre>
<h2 id="guard">Guard</h2>
<p>Use Guard instead of if conditions where is possible</p>
<h5 id="preferred-">Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSmth</span><span class="hljs-params">()</span></span> {
   <span class="hljs-keyword">guard</span> isLogin <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span>
   }

   <span class="hljs-comment">// some actions</span>
}
</code></pre>
<h5 id="not-preferred-">Not Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSmth</span><span class="hljs-params">()</span></span> {
   <span class="hljs-keyword">if</span> isLogin {
      <span class="hljs-comment">// some actions</span>
   }
}
</code></pre>
<h2 id="use-defaults-and-optional-values-in-method">Use Defaults and optional values in method</h2>
<h5 id="preferred-">Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-selector-tag">func</span> <span class="hljs-selector-tag">doSmth</span>(<span class="hljs-attribute">x</span>: Int? = nil, <span class="hljs-attribute">y</span>: Int? = nil) {
    <span class="hljs-selector-tag">print</span>(x)
    <span class="hljs-selector-tag">print</span>(y)
}

<span class="hljs-selector-tag">doSmth</span>()
<span class="hljs-selector-tag">doSmth</span>(<span class="hljs-attribute">x</span>:<span class="hljs-number">5</span>)
<span class="hljs-selector-tag">doSmth</span>(<span class="hljs-attribute">y</span>:<span class="hljs-number">7</span>)
<span class="hljs-selector-tag">doSmth</span>(<span class="hljs-attribute">x</span>:<span class="hljs-number">5</span>, <span class="hljs-attribute">y</span>:<span class="hljs-number">7</span>)
</code></pre>
<h5 id="not-preferred-">Not Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-selector-tag">func</span> <span class="hljs-selector-tag">doSmth</span>() {
    <span class="hljs-selector-tag">print</span>(x)
    <span class="hljs-selector-tag">print</span>(y)
}

<span class="hljs-selector-tag">func</span> <span class="hljs-selector-tag">doSmth</span>(<span class="hljs-attribute">x</span>: Int? = nil) {
    <span class="hljs-selector-tag">print</span>(x)
    <span class="hljs-selector-tag">print</span>(y)
}

....

<span class="hljs-selector-tag">doSmth</span>()
<span class="hljs-selector-tag">doSmth</span>(<span class="hljs-attribute">x</span>:<span class="hljs-number">5</span>)
<span class="hljs-selector-tag">doSmth</span>(<span class="hljs-attribute">y</span>:<span class="hljs-number">7</span>)
<span class="hljs-selector-tag">doSmth</span>(<span class="hljs-attribute">x</span>:<span class="hljs-number">5</span>, <span class="hljs-attribute">y</span>:<span class="hljs-number">7</span>)
</code></pre>
<h2 id="access-level">Access Level</h2>
<p>Omitting an explicit access level is permitted on declarations. For top-level declarations, the default access level is internal. For nested declarations, the default access level is the lesser of internal and the access level of the enclosing declaration.</p>
<p>Specifying an explicit access level at the file level on an extension is forbidden. Each member of the extension has its access level specified if it is different than the default.</p>
<h5 id="preferred-">Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">String</span> </span>{
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> isUppercase: <span class="hljs-type">Bool</span> {
    <span class="hljs-comment">// ...</span>
  }

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> isLowercase: <span class="hljs-type">Bool</span> {
    <span class="hljs-comment">// ...</span>
  }
}
</code></pre>
<h5 id="not-preferred-">Not Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">String</span> </span>{
  <span class="hljs-keyword">var</span> isUppercase: <span class="hljs-type">Bool</span> {
    <span class="hljs-comment">// ...</span>
  }

  <span class="hljs-keyword">var</span> isLowercase: <span class="hljs-type">Bool</span> {
    <span class="hljs-comment">// ...</span>
  }
}
</code></pre>
<h2 id="tuple-patterns">Tuple Patterns</h2>
<p>Assigning variables through a tuple pattern (sometimes referred to as a tuple shuffle) is only permitted if the left-hand side of the assignment is unlabeled.</p>
<h5 id="preferred-">Preferred:</h5>
<pre><code class="lang-swift">let (<span class="hljs-name">a</span>, b) = (<span class="hljs-name">y</span>: <span class="hljs-number">4</span>, x: <span class="hljs-number">5.0</span>)
</code></pre>
<h5 id="not-preferred-">Not Preferred:</h5>
<pre><code class="lang-swift">let (<span class="hljs-string">x:</span> a, <span class="hljs-string">y:</span> b) = (<span class="hljs-string">y:</span> <span class="hljs-number">4</span>, <span class="hljs-string">x:</span> <span class="hljs-number">5.0</span>)
</code></pre>
<h2 id="literals">Literals</h2>
<p>Don&#39;t use literals as some property</p>
<h5 id="preferred-">Preferred:</h5>
<pre><code class="lang-swift">imageView.<span class="hljs-attr">image</span> = <span class="hljs-comment">#ImageLiteral()</span>
</code></pre>
<h5 id="not-preferred-">Not Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-built_in">let</span> <span class="hljs-built_in">image</span> = #ImageLiteral()
imageView.<span class="hljs-built_in">image</span> = <span class="hljs-built_in">image</span>
</code></pre>
<h2 id="unused-code">Unused Code</h2>
<p>Remove all unused delegate, protocol method</p>
<h2 id="separete-functionality">Separete Functionality</h2>
<p>Protocols should be implemented in separate extensions.
Class should include only the code that describes inner functionality.
Add &quot;// MARK: -  some extensions&quot; for define extension</p>
<h5 id="preferred-">Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProfileVC</span>: <span class="hljs-title">UIViewController</span> </span>{

}

<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ProfileVC</span>: <span class="hljs-title">UITableViewDelegate</span> </span>{

}
</code></pre>
<h5 id="not-preferred-">Not Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProfileVC</span>: <span class="hljs-type">UIViewController</span>, <span class="hljs-type">UITableViewDelegate {</span></span>

}
</code></pre>
<h2 id="use-multiple-optional-binding">Use multiple optional binding</h2>
<p>Use multiple optional binding in an if let statement where possible to avoid the pyramid of doom:</p>
<h3 id="prefered">Prefered</h3>
<pre><code class="lang-swift"><span class="hljs-keyword">if</span>
    <span class="hljs-keyword">let</span> id = jsonObject[Constants.Id] <span class="hljs-keyword">as</span>? Int,
    <span class="hljs-keyword">let</span> firstName = jsonObject[Constants.firstName] <span class="hljs-keyword">as</span>? <span class="hljs-built_in">String</span>,
    <span class="hljs-keyword">let</span> lastName = jsonObject[Constants.lastName] <span class="hljs-keyword">as</span>? <span class="hljs-built_in">String</span>,
    <span class="hljs-keyword">let</span> initials = jsonObject[Constants.initials] <span class="hljs-keyword">as</span>? <span class="hljs-title">String</span> {
        <span class="hljs-comment">// Flat</span>
        <span class="hljs-keyword">let</span> user = User(<span class="hljs-attribute">id:</span><span class="hljs-string"> id</span>, <span class="hljs-attribute">name</span>: name, <span class="hljs-attribute">initials</span>: initials)
        <span class="hljs-comment">// ...</span>
}
</code></pre>
<h5 id="not-preferred-">Not Preferred:</h5>
<pre><code class="lang-swift"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> id = jsonObject[Constants.id] <span class="hljs-keyword">as</span>? Int {
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> firstName = jsonObject[Constants.firstName] <span class="hljs-keyword">as</span>? <span class="hljs-built_in">String</span> {
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> lastName = jsonObject[Constants.lastName] <span class="hljs-keyword">as</span>? <span class="hljs-built_in">String</span> {
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> initials = jsonObject[Constants.initials] <span class="hljs-keyword">as</span>? <span class="hljs-built_in">String</span> {
                <span class="hljs-comment">// Deep nesting</span>
                <span class="hljs-keyword">let</span> user = User(id: id, <span class="hljs-attr">firstName</span>: name, <span class="hljs-attr">lastName</span>: lastName, <span class="hljs-attr">initials</span>: initials)
                <span class="hljs-comment">// ...</span>
            }
        }
    }
}
</code></pre>
<h2 id="marks">Marks</h2>
<p>Separate code struct by Marks if needed</p>
<pre><code class="lang-swift"><span class="hljs-comment">// MARK: - Network Requests</span>

... some methods

<span class="hljs-comment">// MARK: - Update UI</span>

... some methods
</code></pre>
<h2 id="assets">Assets</h2>
<p>Assets include <strong>Images</strong>, <strong>Fonts</strong> and <strong>Colors</strong>.</p>
<h3 id="images">Images</h3>
<p>All images are stored inside a single <code>.xcassets</code> folder for each target.</p>
<ul>
<li><p>Main app assets folder path: <code>~Assets/Images.xcassets</code></p>
</li>
<li><p>Assets folder has subgroups for individual components in the app, based on the <code>Application</code> folder structure.</p>
</li>
<li>Naming the images must be done using the existing notation: <code>&lt;tag&gt;_&lt;first word&gt;_&lt;second word&gt;</code> where tag is <code>icon</code> for icons and <code>image</code> for larger images</li>
<li>For icons and flat vector images always use <code>.pdf</code>. For complex images and illustrations use <code>.png</code> (1x size), <code>@2x.png</code> (2x size) and <code>@3x.png</code> (3x size).</li>
</ul>
<h3 id="fonts">Fonts</h3>
<p>All fonts are located inside their specific extensions, so you can obtain it easily from there.</p>
<p>For example we will use <strong>SFCompactDisplay</strong> font.</p>
<p><strong>HOW TO ADD A NEW FONT?</strong></p>
<p>To add a new font, download it using the <code>.otf</code> extension, either from the web or from the design team. (Always make sure the font is free or we have a license).</p>
<p><strong>Note</strong>
<em>If it is not possible to find files with <code>.otf</code> extension but you can find <code>.ttf</code> font you can just change extension in Finder and click
&quot;Use .otf&quot; in the alert you will see.</em></p>
<p>1) Drag and drop all new fonts to the Font folder with the next path <em>~Assets/Fonts</em>
2) Add all new fonts to the target&#39;s plist app to the main dictionary. Then app will know about new fonts in the project.</p>
<pre><code class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>UIAppFonts<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>SF-Compact-Display-Semibold.otf<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>
     ...
     <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>SF-Compact-Display-Medium.otf<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span>
</code></pre>
<p><strong>HOW TO USE AN EXISTING FONT</strong></p>
<p><strong>Note</strong>
<em>Sometimes when you try to use your custom font your app will return nil because it could not find Font Family with the font file name.
To resolve this problem you need to check all possible font families in the app and look for the font you just added and his real name.</em></p>
<p>To check all possible font families throught the code you can use next code in didFinishLaunchWithOption function:</p>
<pre><code class="lang-swift"> UIFont.familyNames.forEach({ familyName <span class="hljs-keyword">in</span>
    <span class="hljs-built_in">let</span> fontNames = UIFont.fontNames(<span class="hljs-keyword">for</span>FamilyName: familyName)
     <span class="hljs-built_in">print</span>(familyName, fontNames)
 })
</code></pre>
<p>Since we have custom font we must create UIFont extension with next template: <strong>UIFont+<FontFamilyName></strong></p>
<ul>
<li>UIFont+SFCompactDisplay.swift</li>
</ul>
<p>In UI font extension we need to add next code:</p>
<pre><code class="lang-swift"> <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">UIFont</span> </span>{
     <span class="hljs-comment">// 1</span>
     <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SFCompactFontWeight</span>: <span class="hljs-title">String</span> </span>{
         <span class="hljs-keyword">case</span> regular = <span class="hljs-string">"Regular"</span>
         <span class="hljs-keyword">case</span> bold = <span class="hljs-string">"Bold"</span>
         <span class="hljs-keyword">case</span> medium = <span class="hljs-string">"Medium"</span>
         <span class="hljs-keyword">case</span> semibold = <span class="hljs-string">"Semibold"</span>
     }
     <span class="hljs-comment">// 2</span>
     <span class="hljs-comment">/**
      Creates SFCompactDisplay font.

      - Parameter size: The size of the font.
      - Parameter weight: The weight of the font.

      - Returns: An instance of SFCompactDisplay font, if it exist, otherwise a system font.
      */</span>
     <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sfCompactDisplay</span><span class="hljs-params">(ofSize size: CGFloat, weight: SFCompactFontWeight = .regular)</span></span> -&gt; <span class="hljs-type">UIFont</span> {
         <span class="hljs-keyword">return</span> <span class="hljs-type">UIFont</span>(name: <span class="hljs-string">"SFCompactDisplay-<span class="hljs-subst">\(weight.rawValue)</span>"</span>, size: size) ?? .systemFont(ofSize: size, weight: .regular)
     }
 }
</code></pre>
<p>// 1
For <em>SFCompactFont</em>. font have different weights, then you need to add enum with possible font&#39;s weights.
// 2
Create method which will return an instance of the font using UIFont inirializator with font name and size</p>
<p><strong>Example</strong></p>
<p><code>SFCompactDisplay</code> font with UILabel:</p>
<pre><code class="lang-swift"> lazy var subtitleLabel = UILabel().<span class="hljs-keyword">then</span> {
     $0.font = .sfCompactDisplay(ofSize: Device.IS_4_7_INCHES_OR_SMALLER() ? <span class="hljs-number">12</span> : <span class="hljs-number">14</span>)
     $0.textColor = .blueyGrey
     $0.numberOfLines = <span class="hljs-number">0</span>

     rightView.addSubview($0)
 }
</code></pre>
<p><strong>HOW TO DELETE AN EXISTING FONT?</strong></p>
<p>1) Update with new font all places in code where the font is used.
2) Delete font extension.
3) Delete font <code>.otf</code> files from folder <strong>Fonts</strong>.
4) Delete font name from plist file</p>
<h3 id="colors">Colors</h3>
<p>The project must have separate <strong>.xcassets</strong> folder for app colors, which will help to see which color is added to be sure that we don&#39;t have duplicates. <a href="https://blog.zeplin.io/asset-catalog-colors-on-xcode-9-c4fdccc0381a">Here</a> is an article how to add colors to <strong>.xcasset</strong> folder.</p>
<p><img width="100%" alt="Screen Shot 2019-09-19 at 10 51 13" src="https://user-images.githubusercontent.com/25178444/65224470-e95e5300-dacb-11e9-807d-8b8e341c4e2e.png"></p>
</body>
</html>