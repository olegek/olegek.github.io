<div align="center">
<h1 id="ios-projects-general-rules">iOS projects general rules</h1>
<p>Comments and suggestions are <strong>STRONGLY ENCOURAGED</strong>, so feel free to open an issue.</p>
<h1 id="contents">Contents</h1>
<ul>
<li><a href="#project-general-rules">Project general rules</a></li>
<li><a href="#project-tree-structure">Project Tree Structure</a></li>
<li><a href="#file-blocks-sctructure">File blocks sctructure</a></li>
<li><a href="#security-guide">Security Guide</a></li>
<li><a href="#branch-guide">Branch Guide</a></li>
<li><a href="#design-architecture">Design Architecture</a></li>
<li><a href="#design-pattern">Design Pattern</a></li>
<li><a href="#managers--services">Managers &amp; Services</a></li>
<li><a href="#helpers">Helpers</a></li>
<li><a href="#code-style-rules">Code style rules</a></li>
<li><a href="#conventions">Conventions</a></li>
<li><a href="#naming">Naming</a></li>
<li><a href="#code-organization">Code Organization</a></li>
<li><a href="#assets">Assets</a>
<ul>
<li><a href="#images">Images</a></li>
<li><a href="#fonts">Fonts</a></li>
<li><a href="#colors">Colors</a></li>
</ul></li>
</ul>
<h1 id="project-general-rules">Project general rules</h1>
<h2 id="project-tree-structure">Project Tree Structure</h2>
<p><img width="338" alt="Project Tree Structure" src="https://user-images.githubusercontent.com/25178444/69141915-6018cc00-0ace-11ea-912d-06fe31cc86b4.png"></p>
<h2 id="file-blocks-structure">File blocks structure</h2>
<h3 id="code-structure-for-files">Code structure for files</h3>
<p><em>(All sections are optional and used if needed)</em></p>
<pre class="swift"><code>
// MARK: - Private properties (views, DateFormatter etc.)

// MARK: - Properties

// MARK: - Closure/Delegate

// MARK: - Lifecycle

// MARK: - Setup with model

// MARK: - Actions

// MARK: - Override

// MARK: - Help methods
</code></pre>
<h2 id="security-guide">Security Guide</h2>
<ol style="list-style-type: decimal">
<li>Use password on your Mac</li>
<li>When you leave your workspace lock Mac (use hot key Command+Control+Q). For detail information <a href="https://macpaw.com/how-to/lock-mac-screen">goto</a></li>
<li>Use FileVault on Mac. <a href="https://support.apple.com/en-us/HT204837">Setup Guide</a></li>
<li>Сhange your password from time to time, don't pass password.</li>
<li>If it possible setup SSL</li>
<li>Use 2-Factor Authentication for Accounts Used for Work:</li>
</ol>
<ul>
<li>Atlassian (Jira, Confluence)</li>
<li>Bitbucket</li>
<li>Gmail/Google</li>
<li>Github</li>
<li>Slack (including workspace used for client work)</li>
<li>Trello</li>
</ul>
<ol start="7" style="list-style-type: decimal">
<li>Do not add certificates or profiles to the repository, do not store passwords in the repository/code</li>
<li>Don't use the main branch for work</li>
</ol>
<h2 id="branch-guide">Branch Guide</h2>
<ol style="list-style-type: decimal">
<li>Don't use the main branch for work! Create:</li>
</ol>
<ul>
<li>branch &quot;development&quot; for development</li>
<li>branch &quot;release&quot; for the release version</li>
<li>branch &quot;beta-testing&quot; for versions delivered to the client for a test (e.g. TestFlight)</li>
</ul>
<ol start="2" style="list-style-type: decimal">
<li>Commit names:</li>
</ol>
<ul>
<li><code>development</code> branch:
<ul>
<li>use Jira task name (or task name/number from trello etc) and short description of the work done in this commit. For example: <code>PB-248, added profile screen</code></li>
</ul></li>
<li><code>release</code> and <code>beta-testing</code> branches:
<ul>
<li>when sending a build to the Store, or to the Testflight, you can use the number of the release/beta verion, e.g: &quot;1.0.2 #19&quot;</li>
</ul></li>
</ul>
<ol start="3" style="list-style-type: decimal">
<li>Create commit for every new task</li>
<li>If you work in a team, use one branch for every separate task. When done, merge task branch into the &quot;develepment&quot; branch</li>
<li>Always work on latest code: before starting new feature, make sure to sync with main active branch</li>
</ol>
<h1 id="design-architecture">Design Architecture</h1>
<h2 id="design-pattern">Design Pattern</h2>
<p>The design pattern we will begin adopting should make the app more modularized and allow for easy navigation through the codebase. It is inspired by MVVM+Coordinator, an alternative to standard MVC, where the business logic is separated from the UI in a <code>ViewModel</code>.</p>
<p>Each component in <code>Application</code> (see <a href="#project-tree-structure">Project Tree Structure</a>) should include <code>$VCName$ViewController.swift</code>, <code>$VMName$ViewModel.swift</code>, (several) <code>$VName$View.swift</code> and (several) <code>$MName$Model.swift</code>.</p>
<p><strong><code>Model.swift</code></strong> * Represents a specific model e.g. <code>UserModel</code>, <code>PropertyModel</code>, <code>History</code> etc. * Does not contain any logic.</p>
<p><strong><code>ViewController.swift</code></strong> * Does not contain any business logic (networking, database, configuring cells, converting variables etc.) * Can't interact with the <code>Model</code>s directly, only with the <code>ViewModel</code>s and <code>View</code>s.</p>
<p><strong><code>View.swift</code></strong> * Represents a UI element e.g. <code>GuestDetailsView</code>, <code>StretchyHeaderView</code> etc. * Does not contain any logic. * Should not be tight to the view controller in order to be extracted as a framework (if applicable).</p>
<p><strong><code>ViewModel.swift</code></strong> * Contains all the business logic. * Communicates with the <code>Coordinators</code>s, <code>Model</code>s and <code>ViewController</code>s(with callbacks, ViewModel should not know about ViewController) but can't interact with the UI (<code>View</code>s).</p>
<p><strong><code>Coordinator.swift</code></strong> * Contains all transition logic * Crates new controllers and their view models</p>
<div class="figure">
<img src="https://user-images.githubusercontent.com/25178444/69136881-5db17480-0ac4-11ea-9a74-329e8a56f5b5.png" alt="MVVM+Coordinator+MoyaNetworking Architecture" /><p class="caption">MVVM+Coordinator+MoyaNetworking Architecture</p>
</div>
<p>Moya <a href="https://github.com/Moya/Moya">Documentation</a> , <a href="https://www.raywenderlich.com/5121-moya-tutorial-for-ios-getting-started">Tutorial</a></p>
<p>Snapkit <a href="http://snapkit.io">Documentation</a> , <a href="https://www.raywenderlich.com/3225401-snapkit-for-ios-constraints-in-a-snap">Tutorial</a></p>
<p>Use the principle of Single Responsible, one class - should perform one action.</p>
<p>For TableView sections Header/Foother use <code>UITableViewHeaderFooterView</code></p>
<p>Similar situation is when the controller has a UIView with some UI components it should be transferred to a separate class that is inherited from the UIView and communicates with the VC</p>
<h2 id="managers-services">Managers &amp; Services</h2>
<p>There should be clear distinguishing between <code>Managers</code> and <code>Services</code>. In simple terms:</p>
<p><strong>Manager</strong> - a singleton object which includes functionality required during the lifetime of the application. We should keep the number of managers to a minimum and ONLY create one when needed.</p>
<p><strong>Services</strong> - a service is NOT a singleton and serves a very specific purpose. It should be independent of any custom logic and be fully reusable. Most services will eventually be transformed into frameworks (swift packages). E.g. <code>PDFSplitService</code>.</p>
<h2 id="helpers">Helpers</h2>
<p><code>Helpers</code> are NOT <code>Services</code>, <code>Managers</code> or <code>Data Models</code>. <code>Helpers</code> are classes, structs, extensions with the purpose of extracting some basic logic. Typically, one helper is used across multiple classes.</p>
<p><strong>Helpers CAN include:</strong> * Extensions (e.g. <code>String+Split.swift</code>). * Methods for converting data. * Handle configurations (e.g. <code>Device.swift</code>)</p>
<p><strong>Helpers CAN NOT include:</strong> * Complex networking calls. * Database interactions. * Data models.</p>
<h1 id="code-style-rules">Code style rules</h1>
<h2 id="conventions">Conventions</h2>
<h3 id="viewer">Viewer</h3>
<p>For best practice use select some code and use Editor -&gt; Format -&gt; Re - Indent</p>
<h3 id="names-of-types-and-variables">Names of types and variables</h3>
<p>Follow case conventions. Names of <strong>types and protocols</strong> are UpperCamelCase. Everything else is lowerCamelCase. Acronyms and initialisms that commonly appear as all upper case in US English should be uniformly up- or down-cased according to case conventions. Other acronyms should be treated as ordinary words.</p>
<h5 id="preferred">Preferred:</h5>
<pre class="swift"><code>var linesArray: [Line]
var shape: Shape

var utf8Bytes: [UTF8.CodeUnit]
var isRepresentableAsASCII = true
var userSMTPServer: SecureSMTPServer</code></pre>
<h5 id="not-preferred">Not Preferred:</h5>
<pre class="swift"><code>var LinesArray: [Line]
var lines_array: [Line]
var sHaPe: Shape

var UTF8Bytes: [UTF8.CodeUnit]</code></pre>
<h3 id="sort-values-by-equal-type">Sort Values by equal type</h3>
<h5 id="preferred-1">Preferred:</h5>
<pre class="swift"><code>var tableView = UITableView()

var headerView = UIView()
var buttonsView = UIView()
var footherView = UIView()

var news: [News]
var sortedNews: [News]</code></pre>
<h5 id="not-preferred-1">Not Preferred:</h5>
<pre class="swift"><code>var headerView = UIView()
var tableView = UITableView()
var buttonsView = UIView()
var news: [News]
var sortedNews: [News]
var footherView = UIView()
</code></pre>
<h3 id="extensions">Extensions</h3>
<p>Use extension to expand classes functionality against global functions.</p>
<h5 id="preferred-2">Preferred:</h5>
<pre class="swift"><code>extension CGRect {

  func doesIntersect(_ anotherRect: CGRect) -&gt; Bool { ... }

}</code></pre>
<h5 id="not-preferred-2">Not Preferred:</h5>
<pre class="swift"><code>// Global Scope

func doRectanglesIntersect(_ rect1: CGRect, _ rect2: CGRect) -&gt; Bool { ... }</code></pre>
<h3 id="methods-names">Methods names</h3>
<p>Methods can share a base name when they share the same basic meaning or when they operate in distinct domains. Examples:</p>
<ol style="list-style-type: decimal">
<li><p>The following is encouraged, since the methods do essentially the same things.</p></li>
<li><p>And since geometric types and collections are separate domains, this is also fine in the same program.</p></li>
<li><p>These index methods have different semantics, and should have been named differently.</p></li>
<li><p>Avoid “overloading on return type” because it causes ambiguities in the presence of type inference.</p></li>
</ol>
<h5 id="preferred-3">Preferred:</h5>
<pre class="swift"><code>// 1
extension Shape {
  func contains(_ other: Point) -&gt; Bool { ... }

  func contains(_ other: Shape) -&gt; Bool { ... }

  func contains(_ other: LineSegment) -&gt; Bool { ... }
}

// 2
extension Collection where Element : Equatable {
  func contains(_ sought: Element) -&gt; Bool { ... }
}</code></pre>
<h5 id="not-preferred-3">Not Preferred:</h5>
<pre class="swift"><code>// 3
extension Database {
  // Rebuilds the database&#39;s search index
  func index() { ... }

  // Returns the n`th row in the given table.
  func index(_ n: Int, inTable: TableID) -&gt; TableRow { ... }
}

// 4
extension Box {
  // Returns the `Int` stored in `self`, if any, and `nil` otherwise.
  func value() -&gt; Int? { ... }

  // Returns the `String` stored in `self`, if any, and `nil` otherwise.
  func value() -&gt; String? { ... }
}</code></pre>
<h3 id="use-short-context">Use short context</h3>
<p>Use compiler inferred context to write shorter, clear code.</p>
<h5 id="preferred-4">Preferred:</h5>
<pre class="swift"><code>let selector = #selector(viewDidLoad)

view.backgroundColor = .red

let toView = context.view(forKey: .to)

let view = UIView(frame: .zero)</code></pre>
<h5 id="not-preferred-4">Not Preferred:</h5>
<pre class="swift"><code>let selector = #selector(ViewController.viewDidLoad)

view.backgroundColor = UIColor.red

let toView = context.view(forKey: UITransitionContextViewKey.to)

let view = UIView(frame: CGRect.zero)</code></pre>
<h2 id="naming">Naming</h2>
<h3 id="funcions-parameters-names">Funcions parameters names</h3>
<p>Choose parameter names to serve documentation. Even though parameter names do not appear at a function’s point of use, they play an important explanatory role.</p>
<p>Choose names to make it easy to read.</p>
<h5 id="preferred-5">Preferred:</h5>
<p>These names make documentation read naturally.</p>
<pre class="swift"><code>// Return an `Array` containing the elements of `self` that satisfy `predicate`.
func filter(_ predicate: (Element) -&gt; Bool) -&gt; [Generator.Element]

// Replace the given `subRange` of elements with `newElements`.
mutating func replaceRange(_ subRange: Range, with newElements: [E])</code></pre>
<h5 id="not-preferred-5">Not Preferred:</h5>
<p>These make the code awkward and ungrammatical.</p>
<pre class="swift"><code>// Return an Array containing the elements of self that satisfy includedInResult.
func filter(_ includedInResult: (Element) -&gt; Bool) -&gt; [Generator.Element]

// Replace the range of elements indicated by r with the contents of with.
mutating func replaceRange(_ r: Range, with: [E])</code></pre>
<h3 id="delegate-methods-naming">Delegate methods naming</h3>
<p>When creating custom delegate methods, an unnamed first parameter should be the delegate source.</p>
<h5 id="preferred-6">Preferred:</h5>
<pre class="swift"><code>func namePickerView(_ namePickerView: NamePickerView, didSelectName name: String)
func namePickerViewShouldReload(_ namePickerView: NamePickerView) -&gt; Bool</code></pre>
<h5 id="not-preferred-6">Not Preferred:</h5>
<pre class="swift"><code>func didSelectName(namePicker: NamePickerViewController, name: String)
func namePickerShouldReload() -&gt; Bool</code></pre>
<h3 id="avoid-ambiguity-naming">Avoid ambiguity naming</h3>
<p>Include all the words needed to avoid ambiguity for a person reading code where the name is used.</p>
<p>Example: If we were to omit the word <strong>at</strong> from the function signature, it could imply to the reader that the function searches for and removes an element equal to x, rather than using x to indicate the position of the element to remove.</p>
<h5 id="preferred-7">Preferred:</h5>
<pre class="swift"><code>extension List {
  func remove(at position: Index) -&gt; Element
}

employees.remove(at: x)</code></pre>
<h5 id="not-preferred-7">Not Preferred:</h5>
<pre class="swift"><code>// unclear: are we removing x?
employees.remove(x)</code></pre>
<h3 id="omit-needless-words">Omit needless words</h3>
<p>Every word in a name should convey useful information at the use site. More words may be needed to clarify intent or disambiguate meaning, but those that are redundant with information the reader already possesses should be omitted. In particular, omit words that merely repeat type information. Example: In this case, the word Element adds nothing useful at the call site.</p>
<h5 id="preferred-8">Preferred:</h5>
<pre class="swift"><code>func remove(_ member: Element) -&gt; Element?

allViews.remove(cancelButton)</code></pre>
<h5 id="not-preferred-8">Not Preferred:</h5>
<pre class="swift"><code>func removeElement(_ member: Element) -&gt; Element?

allViews.removeElement(cancelButton)</code></pre>
<h3 id="name-should-match-the-role">Name should match the role</h3>
<p>Name variables, parameters, and associated types according to their roles.</p>
<h5 id="preferred-9">Preferred:</h5>
<pre class="swift"><code>var greeting = &quot;&quot;Hello&quot;&quot;

protocol ViewController {
  associatedtype ContentView : View
}

class ProductionLine {
  func restock(from supplier: Factory)
}

//

let greetingString = &quot;&quot;http://...&quot;&quot;
let greetingURL = URL(string: greetingString)</code></pre>
<h5 id="not-preferred-9">Not Preferred:</h5>
<pre class="swift"><code>var string = &quot;&quot;Hello&quot;&quot;

protocol ViewController {
  associatedtype ViewType : View
}

class ProductionLine {
  func restock(from factory: Factory)
}

//

let greeting1 = &quot;&quot;http://...&quot;&quot;
let greeting2 = URL(string: greeting1)</code></pre>
<h3 id="selectors-naming">Selectors naming</h3>
<p>Functions that are being used as button selectors directly should be named using the suffix -ButtonAction.</p>
<h5 id="preferred-10">Preferred:</h5>
<pre class="swift"><code>@objc func saveButtonAction() {

}</code></pre>
<h5 id="not-preferred-10">Not Preferred:</h5>
<pre class="swift"><code>@objc func save() {

}</code></pre>
<h3 id="bool-functions-naming">Bool functions naming</h3>
<p>Uses of Bool functions and properties should be read as assertions about the receiver when the use is non-mutating. A verb at the beginning of the name is strongly recommended.</p>
<h5 id="preferred-11">Preferred:</h5>
<pre class="swift"><code>x.isEmpty
line1.doesIntersect(line2)</code></pre>
<h5 id="not-preferred-11">Not Preferred:</h5>
<pre class="swift"><code>x.empty
line1.intersects(line2)</code></pre>
<h2 id="code-organization">Code Organization</h2>
<h3 id="parentheses-around-conditionals">Parentheses around conditionals</h3>
<p>Parentheses around conditionals are not required and should be omitted.</p>
<h5 id="preferred-12">Preferred:</h5>
<pre class="swift"><code>if name == &quot;&quot;Hello&quot;&quot; {
  print(&quot;&quot;World&quot;&quot;)
}</code></pre>
<h5 id="not-preferred-12">Not Preferred:</h5>
<pre class="swift"><code>if (name == &quot;&quot;Hello&quot;&quot;) {
  print(&quot;&quot;World&quot;&quot;)
}</code></pre>
<h3 id="avoid-self">Avoid self</h3>
<p>Avoid self. when it's possible. This will make your code cleaner.</p>
<h5 id="preferred-13">Preferred:</h5>
<pre class="swift"><code>tableView.reloadData()</code></pre>
<h5 id="not-preferred-13">Not Preferred:</h5>
<pre class="swift"><code>self.tableView.reloadData()</code></pre>
<h3 id="avoid-useless-methods-for-computed-properties">Avoid useless methods for computed properties</h3>
<p>For conciseness, if a computed property is read-only, omit the get clause. The get clause is required only when a set clause is provided.</p>
<h5 id="preferred-14">Preferred:</h5>
<pre class="swift"><code>var diameter: Double {
  return radius * 2
}</code></pre>
<h5 id="not-preferred-14">Not Preferred:</h5>
<pre class="swift"><code>var diameter: Double {
  get {
     return radius * 2
  }
}</code></pre>
<h3 id="omit-needless-arguments-for-target-functions.">Omit needless arguments for target functions.</h3>
<h5 id="preferred-15">Preferred:</h5>
<pre class="swift"><code>@objc func saveButtonActtion() {
  // sender is not needed
}</code></pre>
<h5 id="not-preferred-15">Not Preferred:</h5>
<pre class="swift"><code>@objc func saveButtonActtion(_ sender: UIButton) {
  // sender is not needed
}</code></pre>
<h3 id="ternary-operator">Ternary operator</h3>
<p>Prefer to use ternary operator ? : during assignment of a variable with a simple condition.</p>
<h5 id="preferred-16">Preferred:</h5>
<pre class="swift"><code>label.textColor = isAllowed ? .gray : .red</code></pre>
<h5 id="not-preferred-16">Not Preferred:</h5>
<pre class="swift"><code>if isAllowed {
  label.textColor = .gray
} else {
  label.textColor = .red
}</code></pre>
<h3 id="method-braces">Method braces</h3>
<p>Method braces and other braces (if / switch / while etc.) always open on the same line as the statement but close on a new line.</p>
<h5 id="preferred-17">Preferred:</h5>
<pre class="swift"><code>if user.isHappy {
  // Do something
} else {
  // Do something else
}</code></pre>
<h5 id="not-preferred-17">Not Preferred:</h5>
<pre class="swift"><code>if user.isHappy
{
  // Do something
} else
{
  // Do something else
}</code></pre>
<h3 id="separate-methods-logic">Separate methods logic</h3>
<p>Whitespaces and comments within methods should separate logic blocks of functionality. But if your function has to many blocks maybe it's a chance to split the logic to make it less complex.</p>
<h5 id="preferred-18">Preferred:</h5>
<pre class="swift"><code>func hugeFunction() {

  //
  // parsing the input data

  [blockOfFunctionality1]

  //
  // filtering data

  [blockOfFunctionality2]

  //
  // sorting results

  [blockOfFunctionality3]
}</code></pre>
<h5 id="not-preferred-18">Not Preferred:</h5>
<pre class="swift"><code>func hugeFunction() {
  [blockOfFunctionality1]
  [blockOfFunctionality2]
  [blockOfFunctionality3]
}</code></pre>
<h3 id="function-declarations">Function declarations</h3>
<p>Keep short function declarations on one line including the opening brace. For functions with long signatures, use line breaks after each parameter and add an extra indent on subsequent lines.</p>
<pre class="swift"><code>func shortFunction(_ argument: Int) -&gt; Bool {

}</code></pre>
<pre class="swift"><code>func longFunction(
    argument1: Int,
    argument2: Double,
    argument3: Float) -&gt; Bool {

}</code></pre>
<h3 id="closure-return-value">Closure return value</h3>
<p>Don't use (Void) to represent the lack of an input. Use () instead. Only use Void instead of () for closure and function outputs.</p>
<h5 id="preferred-19">Preferred:</h5>
<pre class="swift"><code>let closure: () -&gt; Void</code></pre>
<h5 id="not-preferred-19">Not Preferred:</h5>
<pre class="swift"><code>let closure: (Void) -&gt; Void
let closure: () -&gt; ()</code></pre>
<h3 id="avoid-generic-declaration">Avoid generic declaration</h3>
<p>Prefer the shortcut versions of type declarations over the full generics syntax.</p>
<h5 id="preferred-20">Preferred:</h5>
<pre class="swift"><code>&quot;var deviceModels: [String]
var employees: [Int: String]
var faxNumber: Int?&quot;</code></pre>
<h5 id="not-preferred-20">Not Preferred:</h5>
<pre class="swift"><code>var deviceModels: Array&lt;String&gt;
var employees: Dictionary&lt;Int, String&gt;
var faxNumber: Optional&lt;Int&gt;</code></pre>
<h3 id="use-weak-self-for-closures">Use weak self for closures</h3>
<p><a href="https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html">Apple documentation</a> article which describes how to use weak and unowned.</p>
<p>Extend object lifetime using [weak self] and guard let self = self else { return } idiom.</p>
<p>[weak self] is preferred over [unowned self] where it is not immediately obvious that self outlives the closure.</p>
<p>Global closures don't capture variables. In this case you don't have to use [weak self] or [unowned self], except completion handlers, since there is no guarantee that self will be still in the memory on closure call.</p>
<p>Explicitly extending lifetime is preferred to optional chaining.</p>
<h5 id="preferred-21">Preferred:</h5>
<pre class="swift"><code>resource.request().onComplete { [weak self] response in
  guard let self = self else { return }

  let model = self.updateModel(response)
  self.updateUI(model)
}</code></pre>
<h5 id="not-preferred-21">Not Preferred:</h5>
<pre class="swift"><code>resource.request().onComplete { response in
  let model = self?.updateModel(response)
  self?.updateUI(model)
}</code></pre>
<h2 id="for-where-loops">For-Where Loops</h2>
<h5 id="preferred-22">Preferred:</h5>
<pre class="swift"><code>for item in collection where item.hasProperty {
  // ...
}</code></pre>
<h5 id="not-preferred-22">Not Preferred:</h5>
<pre class="swift"><code>for item in collection {
  if item.hasProperty {
    // ...
  }
}</code></pre>
<h2 id="guard">Guard</h2>
<p>Use Guard instead of if conditions where is possible</p>
<h5 id="preferred-23">Preferred:</h5>
<pre class="swift"><code>func doSmth() {
   guard isLogin else {
      return
   }

   // some actions
}
</code></pre>
<h5 id="not-preferred-23">Not Preferred:</h5>
<pre class="swift"><code>func doSmth() {
   if isLogin {
      // some actions
   }
}</code></pre>
<h2 id="use-defaults-and-optional-values-in-method">Use Defaults and optional values in method</h2>
<h5 id="preferred-24">Preferred:</h5>
<pre class="swift"><code>func doSmth(x: Int? = nil, y: Int? = nil) {
    print(x)
    print(y)
}

doSmth()
doSmth(x:5)
doSmth(y:7)
doSmth(x:5, y:7)
</code></pre>
<h5 id="not-preferred-24">Not Preferred:</h5>
<pre class="swift"><code>func doSmth() {
    print(x)
    print(y)
}

func doSmth(x: Int? = nil) {
    print(x)
    print(y)
}

....

doSmth()
doSmth(x:5)
doSmth(y:7)
doSmth(x:5, y:7)</code></pre>
<h2 id="access-level">Access Level</h2>
<p>Omitting an explicit access level is permitted on declarations. For top-level declarations, the default access level is internal. For nested declarations, the default access level is the lesser of internal and the access level of the enclosing declaration.</p>
<p>Specifying an explicit access level at the file level on an extension is forbidden. Each member of the extension has its access level specified if it is different than the default.</p>
<h5 id="preferred-25">Preferred:</h5>
<pre class="swift"><code>extension String {
  public var isUppercase: Bool {
    // ...
  }

  public var isLowercase: Bool {
    // ...
  }
}</code></pre>
<h5 id="not-preferred-25">Not Preferred:</h5>
<pre class="swift"><code>public extension String {
  var isUppercase: Bool {
    // ...
  }

  var isLowercase: Bool {
    // ...
  }
}</code></pre>
<h2 id="tuple-patterns">Tuple Patterns</h2>
<p>Assigning variables through a tuple pattern (sometimes referred to as a tuple shuffle) is only permitted if the left-hand side of the assignment is unlabeled.</p>
<h5 id="preferred-26">Preferred:</h5>
<pre class="swift"><code>let (a, b) = (y: 4, x: 5.0)</code></pre>
<h5 id="not-preferred-26">Not Preferred:</h5>
<pre class="swift"><code>let (x: a, y: b) = (y: 4, x: 5.0)</code></pre>
<h2 id="literals">Literals</h2>
<p>Don't use literals as some property</p>
<h5 id="preferred-27">Preferred:</h5>
<pre class="swift"><code>imageView.image = #ImageLiteral()</code></pre>
<h5 id="not-preferred-27">Not Preferred:</h5>
<pre class="swift"><code>let image = #ImageLiteral()
imageView.image = image</code></pre>
<h2 id="unused-code">Unused Code</h2>
<p>Remove all unused delegate, protocol method</p>
<h2 id="separete-functionality">Separete Functionality</h2>
<p>Protocols should be implemented in separate extensions. Class should include only the code that describes inner functionality. Add &quot;// MARK: - some extensions&quot; for define extension</p>
<h5 id="preferred-28">Preferred:</h5>
<pre class="swift"><code>class ProfileVC: UIViewController {

}

extension ProfileVC: UITableViewDelegate {

}</code></pre>
<h5 id="not-preferred-28">Not Preferred:</h5>
<pre class="swift"><code>class ProfileVC: UIViewController, UITableViewDelegate {

}</code></pre>
<h2 id="use-multiple-optional-binding">Use multiple optional binding</h2>
<p>Use multiple optional binding in an if let statement where possible to avoid the pyramid of doom:</p>
<h3 id="prefered">Prefered</h3>
<pre class="swift"><code>if
    let id = jsonObject[Constants.Id] as? Int,
    let firstName = jsonObject[Constants.firstName] as? String,
    let lastName = jsonObject[Constants.lastName] as? String,
    let initials = jsonObject[Constants.initials] as? String {
        // Flat
        let user = User(id: id, name: name, initials: initials)
        // ...
}</code></pre>
<h5 id="not-preferred-29">Not Preferred:</h5>
<pre class="swift"><code>if let id = jsonObject[Constants.id] as? Int {
    if let firstName = jsonObject[Constants.firstName] as? String {
        if let lastName = jsonObject[Constants.lastName] as? String {
            if let initials = jsonObject[Constants.initials] as? String {
                // Deep nesting
                let user = User(id: id, firstName: name, lastName: lastName, initials: initials)
                // ...
            }
        }
    }
}</code></pre>
<h2 id="marks">Marks</h2>
<p>Separate code struct by Marks if needed</p>
<pre class="swift"><code>// MARK: - Network Requests

... some methods

// MARK: - Update UI

... some methods
</code></pre>
<h2 id="assets">Assets</h2>
<p>Assets include <strong>Images</strong>, <strong>Fonts</strong> and <strong>Colors</strong>.</p>
<h3 id="images">Images</h3>
<p>All images are stored inside a single <code>.xcassets</code> folder for each target. - Main app assets folder path: <code>~Assets/Images.xcassets</code></p>
<ol style="list-style-type: decimal">
<li>Assets folder has subgroups for individual components in the app, based on the <code>Application</code> folder structure.</li>
<li>Naming the images must be done using the existing notation: <code>&lt;tag&gt;_&lt;first word&gt;_&lt;second word&gt;</code> where tag is <code>icon</code> for icons and <code>image</code> for larger images</li>
<li>For icons and flat vector images always use <code>.pdf</code>. For complex images and illustrations use <code>.png</code> (1x size), <code>@2x.png</code> (2x size) and <code>@3x.png</code> (3x size).</li>
</ol>
<h3 id="fonts">Fonts</h3>
<p>All fonts are located inside their specific extensions, so you can obtain it easily from there.</p>
<p>For example we will use <strong>SFCompactDisplay</strong> font.</p>
<p><strong>HOW TO ADD A NEW FONT?</strong></p>
<p>To add a new font, download it using the <code>.otf</code> extension, either from the web or from the design team. (Always make sure the font is free or we have a license).</p>
<p><strong>Note</strong> <em>If it is not possible to find files with <code>.otf</code> extension but you can find <code>.ttf</code> font you can just change extension in Finder and click &quot;Use .otf&quot; in the alert you will see.</em></p>
<ol style="list-style-type: decimal">
<li>Drag and drop all new fonts to the Font folder with the next path <em>~Assets/Fonts</em></li>
<li>Add all new fonts to the target's plist app to the main dictionary. Then app will know about new fonts in the project.</li>
</ol>
<pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;key&gt;</span>UIAppFonts<span class="kw">&lt;/key&gt;</span>
<span class="kw">&lt;array&gt;</span>
     <span class="kw">&lt;string&gt;</span>SF-Compact-Display-Semibold.otf<span class="kw">&lt;/string&gt;</span>
     ...
     <span class="kw">&lt;string&gt;</span>SF-Compact-Display-Medium.otf<span class="kw">&lt;/string&gt;</span>
<span class="kw">&lt;/array&gt;</span></code></pre>
<p><strong>HOW TO USE AN EXISTING FONT</strong></p>
<p><strong>Note</strong> <em>Sometimes when you try to use your custom font your app will return nil because it could not find Font Family with the font file name. To resolve this problem you need to check all possible font families in the app and look for the font you just added and his real name.</em></p>
<p>To check all possible font families throught the code you can use next code in didFinishLaunchWithOption function:</p>
<pre class="swift"><code> UIFont.familyNames.forEach({ familyName in
    let fontNames = UIFont.fontNames(forFamilyName: familyName)
     print(familyName, fontNames)
 })</code></pre>
<p>Since we have custom font we must create UIFont extension with next template: <strong>UIFont+<FontFamilyName></strong></p>
<ul>
<li>UIFont+SFCompactDisplay.swift</li>
</ul>
<p>In UI font extension we need to add next code:</p>
<pre class="swift"><code> extension UIFont {
     // 1
     enum SFCompactFontWeight: String {
         case regular = &quot;Regular&quot;
         case bold = &quot;Bold&quot;
         case medium = &quot;Medium&quot;
         case semibold = &quot;Semibold&quot;
     }
     // 2
     /**
      Creates SFCompactDisplay font.

      - Parameter size: The size of the font.
      - Parameter weight: The weight of the font.

      - Returns: An instance of SFCompactDisplay font, if it exist, otherwise a system font.
      */
     static func sfCompactDisplay(ofSize size: CGFloat, weight: SFCompactFontWeight = .regular) -&gt; UIFont {
         return UIFont(name: &quot;SFCompactDisplay-\(weight.rawValue)&quot;, size: size) ?? .systemFont(ofSize: size, weight: .regular)
     }
 }</code></pre>
<p>// 1 For <em>SFCompactFont</em>. font have different weights, then you need to add enum with possible font's weights. // 2 Create method which will return an instance of the font using UIFont inirializator with font name and size</p>
<p><strong>Example</strong></p>
<p><code>SFCompactDisplay</code> font with UILabel:</p>
<pre class="swift"><code> lazy var subtitleLabel = UILabel().then {
     $0.font = .sfCompactDisplay(ofSize: Device.IS_4_7_INCHES_OR_SMALLER() ? 12 : 14)
     $0.textColor = .blueyGrey
     $0.numberOfLines = 0

     rightView.addSubview($0)
 }</code></pre>
<p><strong>HOW TO DELETE AN EXISTING FONT?</strong></p>
<ol style="list-style-type: decimal">
<li>Update with new font all places in code where the font is used.</li>
<li>Delete font extension.</li>
<li>Delete font <code>.otf</code> files from folder <strong>Fonts</strong>.</li>
<li>Delete font name from plist file</li>
</ol>
<h3 id="colors">Colors</h3>
<p>The project must have separate <strong>.xcassets</strong> folder for app colors, which will help to see which color is added to be sure that we don't have duplicates. <a href="https://blog.zeplin.io/asset-catalog-colors-on-xcode-9-c4fdccc0381a">Here</a> is an article how to add colors to <strong>.xcasset</strong> folder.</p>
<p><img width="1348" alt="Screen Shot 2019-09-19 at 10 51 13" src="https://user-images.githubusercontent.com/25178444/65224470-e95e5300-dacb-11e9-807d-8b8e341c4e2e.png"></p>
</div>
